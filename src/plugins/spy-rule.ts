import type { SpyConfigRuleEntity } from '@/entities/spy-config-rule.entity.js';
import type { Rule, RuleConfig } from './rule.schema.js';
import { trimStartAndEndSlash } from '@/utils/index.js';
import { ResponseTransformerExpression } from './response-transformer/response-transformer-expression.js';
import { ResponseTransformerPlugin } from './response-transformer/response-transformer.js';

/**
 * TODO: Hard coded allowed plugins
 */
export const allowedPlugins = [ResponseTransformerPlugin.name];
/**
 * Spec
 * 
 *     - Expression syntax for `**response_transformer**`
        1. `<action> = <value>`, the value is JSON-compatibility data
        2. `<action> = <key> : <value>`, the value is JSON-compatibility data
        3. Multiple expressionâ‡’ 
            1. Ex:  `<action> = <value> , <action> = <value>`
            2. Ex: `<action> = <value> , <action> = <key> : <value>`
    - Allow Actions
        - replace.status_code
            - `replace.status_code=400`
 */

export class SpyRule {
  public errorMessages: string[] = [];
  public rules: Record<string, Rule> = {};
  public actionExpressions: string[] = [];

  constructor(public readonly spyConfigRules: SpyConfigRuleEntity[]) {}

  parse(): RuleConfig {
    const ruleConfig = this.parseData();
    return this.parsePlugin(ruleConfig);
  }

  parseData(): RuleConfig {
    for (const spyConfigRule of this.spyConfigRules) {
      const ruleId = this.generateRuleId(spyConfigRule);
      if (this.rules[ruleId]) {
        this.errorMessages.push(`Duplicate rule found for ${ruleId}, payload: ${JSON.stringify(spyConfigRule)}`);
        continue;
      }
      const { actionExpressions, errorMessages } = this.parseActionExpressions(spyConfigRule.data);
      this.errorMessages.push(...errorMessages);
      if (errorMessages.length === 0) {
        this.rules[ruleId] = {
          ruleName: spyConfigRule.ruleName,
          path: spyConfigRule.path,
          method: spyConfigRule.method ?? undefined,
          plugin: spyConfigRule.plugin,
          actionExpressions,
          condition: spyConfigRule.condition,
        };
      }
    }

    return {
      rules: this.rules,
      errorMessages: this.errorMessages,
    };
  }

  /**
   * TODO: Duplicate code from `SpyRulePlugin`
   */

  parsePlugin(ruleConfig: RuleConfig): RuleConfig {
    for (const [ruleId, rule] of Object.entries(ruleConfig.rules)) {
      if (!allowedPlugins.includes(rule.plugin ?? '')) {
        this.errorMessages.push(`Invalid plugin: ${rule.plugin}`);
        delete ruleConfig.rules[ruleId as keyof typeof ruleConfig.rules];
        continue;
      }
      if (rule.plugin === ResponseTransformerPlugin.name) {
        const result = new ResponseTransformerExpression(rule).execute();
        if (!result.success) {
          delete ruleConfig.rules[ruleId as keyof typeof ruleConfig.rules];
          this.errorMessages.push(...result.errorMessages);
        }
      }
    }
    return ruleConfig;
  }

  parseActionExpressions(data: string): {
    actionExpressions: Rule['actionExpressions'];
    errorMessages: string[];
  } {
    const errorMessages: string[] = [];
    const actionExpressions: Rule['actionExpressions'] = [];
    const rawExpressions = data.split(',').map(actionExpression => actionExpression.trim());
    for (const rawExpression of rawExpressions) {
      const [action, param] = rawExpression.split('=');

      if (!action) {
        errorMessages.push(`Action name is missing in the expression: "${rawExpression}"`);
        continue;
      }

      if (!param) {
        errorMessages.push(`Param is missing in the expression: "${rawExpression}"`);
        continue;
      }

      actionExpressions.push({
        action: action.trim(),
        param: param.trim(),
      });
    }
    return {
      actionExpressions,
      errorMessages,
    };
  }

  /**
   * The rule id is generated by the following format:
   * `plugin`-`path`-`method`
   */
  generateRuleId(rule: Partial<SpyConfigRuleEntity>): string {
    const plugin = rule.plugin?.toLowerCase() ?? undefined;
    const method = rule.method?.toLowerCase() ?? undefined;
    const path = rule.path?.toLowerCase() ?? undefined;
    return [
      // Add the plugin,
      ...(plugin ? [plugin] : []),
      // Add the path,
      ...(path ? [trimStartAndEndSlash(path)] : []),
      // Add the method,
      ...(method ? [method] : []),
    ].join(':');
  }
}
